<!doctype html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Thread Safety Basics on iOS/OS X</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/img/favicon/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/img/favicon/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/img/favicon/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/img/favicon/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/img/favicon/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/img/favicon/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/img/favicon/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon/apple-touch-icon-180x180.png">
    <meta name="apple-mobile-web-app-title" content="Parse">
    <link rel="icon" type="image/png" href="/img/favicon/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/img/favicon/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/img/favicon/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/img/favicon/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/img/favicon/favicon-32x32.png" sizes="32x32">
    <meta name="msapplication-TileColor" content="#5298fc">
    <meta name="msapplication-TileImage" content="/img/favicon/apple-touch-icon-144x144.png">
    <meta name="application-name" content="Parse">
    <meta name="theme-color" content="#5298fc">
    <!-- CSS -->
    <!-- build:css -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css">
    <link href="/css/blog.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" rel="stylesheet" />
    <!-- endbuild -->
    <!--[if lte IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/classlist/2014.01.31/classList.min.js"></script>
    <![endif]-->
    <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.2/anchor.js"></script>
    <!--[if lt IE 8]>
    <link rel="stylesheet" type="text/css" href="/stylesheets/ie7.css" />
    <![endif]-->
    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/stylesheets/ie8.css" />
    <![endif]-->
    <!--[if lt IE 10]>
    <link rel="stylesheet" type="text/css" href="/stylesheets/ie89.css" />
    <![endif]-->
    <script>if(Function('/*@cc_on return document.documentMode===10@*/')()){document.documentElement.className+=' ie10';}</script>
    <meta name="csrf-param" content="authenticity_token">
    <meta name="csrf-token" content="KxDoKysxiXDIRV8VXwDYlQStDGzjbGZ24y6ZgQLYAsE=">
    <meta name="description" content="The best place to stay up-to-date with the latest Parse news and events.
">
    <meta name="keywords" content="backend, mobile, development, server, code">
    <meta property="fb:app_id" content="361736430535656">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Parse">
    <meta property="og:image" content="http://blog.parseplatform.org//assets/images/social.jpg">
    <meta property="og:description" content="The best place to stay up-to-date with the latest Parse news and events.
">
    <meta property="og:url" content="http://blog.parseplatform.org//learn/thread-safety-basics-on-iosos-x/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body class="pure p_docs p_docs_index  user_logged_in">
<div class="site__wrapper">
    <div class="site__content">
        <div class="content__wrapper">
            <header class="site__header site__header--white">
    <div class="container">
        <a href="/" class="header-logo">
            <span class="hidden">Parse</span>
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
            	 viewBox="0 0 152 60" style="enable-background:new 0 0 152 60;" xml:space="preserve">
            <g>
            	<path class="line one" d="M23.072,39.678c-0.011,3.348-2.395,4.615-4.909,4.615c-2.851,0-4.541-1.701-4.541-4.357
            		c0-2.964,2.031-4.667,5.35-4.725h13.611c6.428,0.079,10.137-5.391,10.137-9.953c0-4.598-3.485-9.598-9.622-9.842
            		c-6.083-0.242-9.99,5.281-9.99,11.167v3.863"/>
            	<path class="line two" d="M23.072,39.678c-0.011,3.348-2.395,4.615-4.909,4.615c-2.851,0-4.541-1.701-4.541-4.357
            		c0-2.964,2.031-4.667,5.35-4.725h13.611c6.428,0.079,10.137-5.391,10.137-9.953c0-4.598-3.485-9.598-9.622-9.842
            		c-6.083-0.242-9.99,5.281-9.99,11.167v3.863"/>
            	<path class="line three" d="M23.072,39.678c-0.011,3.348-2.395,4.615-4.909,4.615c-2.851,0-4.541-1.701-4.541-4.357
            		c0-2.964,2.031-4.667,5.35-4.725h13.611c6.428,0.079,10.137-5.391,10.137-9.953c0-4.598-3.485-9.598-9.622-9.842
            		c-6.083-0.242-9.99,5.281-9.99,11.167v3.863"/>
            	<path class="st1" d="M151.88,31.106c0-4.561-2.575-7.835-7.173-7.872c-5.665-0.037-9.197,4.12-9.197,10.484v0.11
            		c0,6.033,3.863,9.601,9.601,9.601c1.839,0,4.083-0.405,5.739-1.177v-3.568c-1.839,0.956-3.752,1.398-5.408,1.398
            		c-3.568,0-6.07-1.803-6.18-5.959h12.36C151.807,33.056,151.88,32.026,151.88,31.106z M148.312,31.07h-8.829
            		c0.625-3.053,2.354-4.745,4.966-4.745c2.575,0,3.863,1.729,3.863,4.561V31.07z"/>
            	<path class="st1" d="M125.725,34.712l0.405,0.147c2.869,1.03,3.531,1.655,3.531,2.906c0,1.471-0.993,2.428-3.458,2.428
            		c-1.986,0-4.12-0.662-6.364-1.692v3.752c1.803,0.699,4.12,1.177,6.364,1.177c4.819,0,7.21-2.428,7.21-5.812
            		c0-2.943-1.471-4.525-5.408-5.959l-0.405-0.147c-3.127-1.14-3.752-1.655-3.752-2.869c0-1.361,0.956-2.281,3.237-2.281
            		c1.839,0,3.642,0.589,5.408,1.435v-3.531c-1.582-0.625-3.348-1.03-5.26-1.03c-4.598,0-7.1,2.575-7.1,5.886
            		C120.134,31.695,121.679,33.24,125.725,34.712"/>
            	<path class="st1" d="M110.863,29.892c1.288-2.023,3.09-3.016,5.26-3.016c0.773,0,1.508,0.11,2.17,0.331v-3.384
            		c-0.625-0.258-1.361-0.405-2.134-0.405c-2.281,0-4.01,1.03-5.518,3.09l-0.258-2.869h-3.164v19.386h3.642V29.892z"/>
            	<path class="st1" d="M96.481,23.197c-2.281,0-4.672,0.699-6.474,1.692v3.605c2.023-1.251,4.378-2.023,6.254-2.023
            		c2.612,0,3.679,1.14,3.679,3.274v1.619c-5.334,0.147-8.461,1.03-10.116,2.685c-1.177,1.14-1.692,2.685-1.692,4.267
            		c0,3.274,2.354,5.15,5.702,5.15c2.244,0,4.378-0.92,6.327-2.796l0.221,2.354h3.164V30.003
            		C103.544,25.405,101.263,23.197,96.481,23.197z M99.938,37.728c-1.471,1.619-3.2,2.722-5.297,2.722
            		c-1.729,0-2.833-0.883-2.833-2.428c0-2.281,1.876-3.642,8.13-3.826V37.728z"/>
            	<path class="st1" d="M77.609,17.643h-8.571v25.383h3.826v-8.314h4.745c5.923,0,9.491-3.164,9.491-8.498V26.14
            		C87.1,20.806,83.532,17.643,77.609,17.643z M83.311,26.214c0,3.421-1.986,5.04-5.444,5.04h-5.003V21.101h5.04
            		c3.421,0,5.408,1.619,5.408,5.04V26.214z"/>
            	<path class="st1" d="M27.838,2.192C12.204,2.192-0.12,14.589-0.12,30.15c0,15.597,12.323,27.958,27.958,27.958
            		c15.634,0,27.958-12.36,27.958-27.958C55.795,14.589,43.472,2.192,27.838,2.192z M32.473,36.955H18.752
            		c-1.986,0-3.164,1.214-3.164,3.017c0,1.582,1.067,2.722,2.612,2.722c1.766,0,2.796-1.214,2.906-3.016h4.01
            		c-0.184,4.341-2.906,6.658-6.953,6.658c-3.789,0-6.585-2.575-6.585-6.401c0-3.973,2.98-6.769,7.394-6.769h13.611
            		c4.598,0,8.093-3.348,8.093-7.909c0-4.598-3.127-7.799-7.578-7.799c-4.414,0-7.946,3.237-7.946,9.123v3.863h-4.046v-3.863
            		c0-7.872,5.076-12.986,12.066-12.986c6.695,0,11.551,4.782,11.551,11.588C44.723,32.026,39.499,36.955,32.473,36.955z"/>
            </g>
            </svg>
        </a>
        <a class="header-hamburger" data-menu-trigger="toggle">
            <span class="header-hamburger__wrap">
                <span class="header-hamburger__line--top"></span>
                <span class="header-hamburger__line--middle"></span>
                <span class="header-hamburger__line--bottom"></span>
                <span class="header-hamburger__line--arrow-top"></span>
                <span class="header-hamburger__line--arrow-bottom"></span>
            </span>
        </a>
        <ul class="header-nav">
            <li><a href="http://docs.parseplatform.org">Docs</a></li>
            <li><a class="active" href="/">Blog</a></li>
        </ul>
	</div><!-- container -->
</header>

            <aside class="hero hero--docs-landing">
    <div class="grid-container">
        <div class="col--9">
            <div class="hero--docs-landing__content">
                
                
                <div>
    <span class="author">Richard Ross -</span>
    <span class="date">
        November
        
        3rd,
          
        2015
    </span>
</div>

                <h1 class="h1 h1--white">
                    Thread Safety Basics on iOS/OS X
                </h1>
            </div>
        </div>
    </div>
</aside><!-- .hero -->
<div class="container padding-top-40 padding-bottom-50" data-nav-waypoint>
    <article role="article" class="posts">
        
        <div>
    
    <a href="/blog/categories/engineering" class="btn btn--dark--outline btn--xsmall category">Engineering</a>
    
    <a href="/blog/categories/learn" class="btn btn--dark--outline btn--xsmall category">Learn</a>
    
</div>

        <div class="padding-bottom-20 padding-top-20">
  
  
</div>
        <div class="padding-bottom-40 post"><p>Dealing with concurrency and reentrancy is one of the more difficult challenges any library will inevitably face as it grows. Here at Parse, we have put a large effort towards ensuring that anything you do with our SDKs is thread-safe, without letting performance suffer.</p>

<p>In this article, we’ll go over some of the basic concepts about about how the you can handle concurrency and race conditions in a clean, concise, safe, way.</p>

<p>First, before we get into the gritty details, let’s get a few definitions out of the way.</p>

<ul class="standard-list">
  <li>
    <b>Thread: </b>A context of execution of a program, scheduled for running by the Operating System. Any number of these can exist at once.
  </li>
  <li>
    <b>Concurrency: </b>A state of execution in which multiple threads are performing tasks on the same shared resource.
  </li>
  <li>
    <b>Reentrancy: </b>A state of execution in which a function re-enters itself, either via explicit recursion, software/hardware interrupt, or other methods.
  </li>
  <li>
    <b>Atomicity: </b>A property of an operation such that it is guaranteed to finish or fail, but can never end up or produce an intermediate state, or an invalid state.
  </li>
  <li>
    <b>Thread Safe: </b>A function is thread safe if, and only if, invalid state cannot be caused, or observed, by entering a state of concurrency.
  </li>
  <li>
    <b>Re-entrant: </b>A function is re-entrant if, and only if, invalid state cannot be caused, or observed, by entering a state of reentrancy.
  </li>
</ul>

<p><strong>The first thing that should always be discussed when talking about thread safety is that thread safety is inherently hard.</strong> Due to the way that threading, scheduling, garbage collection, cache misses, branch predictions, etc. work, issues with threading can be <em>very</em> difficult to trace down and fix. Given these factors, whenever possible, do not write code that can fail in a multithreaded environment. That can be achieved quite simply, if you follow the following guidelines:</p>

<ul class="standard-list">
  <li>
    Don't have mutable state whenever possible. Copies, copies, copies.
  </li>
  <li>
    Yes, your code has a race condition.
  </li>
  <li>
    Prefer thread-local storage over global state when it makes sense.
  </li>
  <li>
    When in doubt, use a lock.
  </li>
  <li>
    <b>Yes, your code has a race condition</b> (even if you think it's impossible).
  </li>
</ul>

<h1 id="race-conditions">Race Conditions</h1>

<p>Race conditions. The bane of any multithreaded system. When you don’t directly control scheduling (as is what happens in a single thread), how can you ensure that things happen in the order that you expect them to? There is a lot of good advice on the internet about <a href="http://www.cs.cmu.edu/~nbeckman/papers/race_detection_survey.pdf">how to track down race conditions</a>, but surprisingly little about avoiding them.</p>

<p>Most race conditions are caused by shared mutable state, such as the following:</p>

<pre class="line-numbers"><code class="language-objectivec">void thread1() {
    _sharedState = 1;

    // Do stuff

    if (someCondition) {
        _sharedState = 0;
    }

    // Do stuff

    _sharedState = 1;
}

void thread2() {
    // Do stuff

    if (_sharedState == 0) {
        _sharedState = 1;
    }

    // Do stuff
}</code></pre>

<p>If thread 1’s <code class="highlighter-rouge">someCondition</code> evaluates to <code class="highlighter-rouge">true</code>, will _sharedState be 0 or 1? That depends on the state of thread 2, and whether or not it has evaluated its conditional yet.</p>

<p>Mutable state does not necessarily mean variables, either. State can be modified outside the realm of your application, including the file system, network, syscalls, and more.</p>

<h2 id="states-and-copying">States and Copying</h2>

<p>One of the best ways to avoid mutable state is to have strict guidelines on how you manage state as a whole. In general, at Parse, we adhere to three rules:</p>

<ol class="standard-list">
  <li>
    Separate your state from the code that modifies it. This allows you to have a clear separation of concerns between your reading and mutation, and allows you to better reason about threading in your code.
  </li>
  <li>
    Pass <b>anything</b> mutable by copy. Passing by reference creates the possibility of concurrent resource modification, and you will need to do some form of synchronization to ensure this doesn't happen.
  </li>
  <li>
    When in doubt, just lock. It may be slower, but it's better than having a 1-in-1000 race condition that breaks your app.
  </li>
</ol>

<p>Remember that global state is bad, and you should avoid it at all costs (yes, this includes singletons). At Parse, we prefer to use dependency injection over things like singletons (e.g. <code class="highlighter-rouge">-initWithObjectController:</code> vs. <code class="highlighter-rouge">[ObjectController sharedController]</code>), as it helps us keep track of our usages of objects, as well as strengthen our reasoning about threading, and use thread-local stoage vs. global if it makes sense.</p>

<p>As mentioned above, mutable states (as well as global state) make concurrency significantly harder to cope with than it should be. Avoid it at all costs.</p>

<h2 id="atomicity">Atomicity</h2>

<p>As stated above, atomicity is defined as follows:</p>

<ul class="standard-list">
  <li>
    A property of an operation such that it is guaranteed to finish or fail, but can never end up or produce an intermediate state, or an invalid state.
  </li>
</ul>

<p>That’s great, albeit a bit cryptic. What does that mean in practice, though?</p>

<p>Imagine you have a counter variable named <code class="highlighter-rouge">y</code>, which needs to be updated from multiple threads. A naive solution to this problem would be to directly increment, such as <code class="highlighter-rouge">y++</code>. However, there’s a critical flaw with this operation. What happens if two threads try to increment <code class="highlighter-rouge">y</code> at the same time? You end up in a non-deterministic state, and you’re forced to find another solution.</p>

<p>One solution might be to stick a lock around your counter variable, but that would decrease performance significantly. Another solution (depending on the situation) might be to use a separate counter on a per-thread basis, but that increases memory usage and cognitive load of your program.</p>

<p>There is, however, a better way. Using some processor specific instructions, abstracted away using the functions provide <code class="highlighter-rouge">&lt;libkern/OSAtomic.h&gt;</code>, which guarantees that all operations performed on an address are properly synchronized, and are enforced by the processor, not by the operating system. These are the basis for creating lock-free data structures, very useful entities, but well outside the scope of this blog post.</p>

<p>As a general rule though, if every operation you perform on a specified address is atomic, no reads to that address can put your application in an invalid state. These primitives, then, when combined with atomic properties, can ensure than any single field cannot be in an invalid state. Note that the object as a whole may still be able to be in an invalid state, as every atomic operation you perform is entirely independent of all other atomic operations that are being executed on other addresses.</p>

<h2 id="locking">Locking</h2>

<p>When atomics won’t serve your purpose, you do have the more ‘traditional’ method of thread safety in locking. Locking exists in many forms, with many contradicting opinions on what kind of lock is the ‘best’ for a situation. We will discuss a few of the options available by default on iOS/OS X.</p>

<p>Before we discuss <em>how</em> to lock, lets talk about <em>when</em> <em>**</em>to lock. One of the largest mistakes that is made when developing ‘thread-safe’ code, is overaggressive use of locking. Yes, if you lock every single possible method call to an object, there’s no possible chance of a race condition. However, you can do significantly better if you can isolate the sections where you have access to mutable state.</p>

<p>Now, to demonstrate several kinds of locks, let’s begin with an example:</p>

<pre class="line-numbers"><code class="language-objectivec">- (NSInteger)foo {
    return _foo;
}

- (void)incrementFooBy:(NSInteger)x {
    _foo += x;
}</code></pre>

<p>This simple function, while appearing completely harmless, is neither thread-safe or re-entrant. In fact, there are multiple issues with this snippet of code:</p>

<ul class="standard-list">
  <li>
    In the concurrent use-case, the operator <code>*=</code> is not atomic. This means that if two threads call <code>incrementFooBy:</code> at exactly the same time, we will end up with an intermediate value that may not represent any valid state at all.
  </li>
  <li>
    In the re-entrant use-case, if an interrupt is raised between the multiplication and the assignment, we have a very similar problem to above, where we may end up in a strange intermediate issue.
  </li>
</ul>

<p>Hmm. So this code doesn’t work. How can we make it better?</p>

<h2 id="approach-1-synchronized">Approach 1: <code class="highlighter-rouge">@synchronized</code></h2>

<pre class="line-numbers"><code class="language-objectivec">- (NSInteger)foo {
    @synchronized (self) {
        return _foo;
    }
}

- (void)incrementFooBy:(NSInteger)x {
    @synchronized (self) {
        _foo += x;
    }
}</code></pre>

<p>This solves both the concurrency and the re-entrancy problem, but it provides issues of its own as well. The first, and most obvious issue, is that by synchronizing on <code class="highlighter-rouge">self</code>, we restrict any other thread from synchronizing on <code class="highlighter-rouge">self</code>, which can be very bad if you over-use this.</p>

<p>The second issue with this solution is performance of <code class="highlighter-rouge">@synchronized</code> is <a href="http://perpendiculo.us/2009/09/synchronized-nslock-pthread-osspinlock-showdown-done-right/">well known</a> to be <a href="http://cocoasamurai.blogspot.com/2008/04/osspinlock-lock-showdown-posix-locks-vs.html">dismal at best</a>. However, it still is the simplest way to create a lock in Objective-C, and as such it is still used widely. That doesn’t mean that better options do not exist, however, which brings us to…</p>

<h2 id="approach-2-serial-dispatch-queue">Approach 2: Serial dispatch queue</h2>

<p>At some point in your Cocoa/Cocoa Touch programming career, you probably have touched one of these, even if it is just the main queue. A dispatch queue is a list of tasks that are executed in a linear fashion, by whichever threads are available from the OS. Dispatch queues have a few unique properties however, which make them more than suitable for synchronization.</p>

<pre class="line-numbers"><code class="language-objectivec">@implementation SomeObject() {
    dispatch_queue_t _barQueue; // = dispatch_queue_create("com.parse.example.queue", DISPATCH_QUEUE_SERIAL);
}

- (NSInteger)foo {
    __block NSInteger result = 0;
    dispatch_sync(_barQueue, ^{
        result = _foo;
    });
    return result;
}

- (void)incrementFooBy:(NSInteger) x {
    dispatch_sync(_barQueue, ^{
        _foo += x;
    });
}

@end</code></pre>

<ul class="standard-list">
  <li>
    All dispatch queues, aside from the main queue, will ignore signal interrupts, making sources of reentrancy significantly more logical.
  </li>
  <li>
    Dispatch queues, via their QoS system, are immune to <a href="https://en.wikipedia.org/wiki/Priority_inversion">Priority Inversion</a>.
  </li>
  <li>
    Can do deferred execution via dispatch_async, without breaking synchronization model.
  </li>
</ul>

<p>However, there are some downsides to using dispatch queues as your source of mutual exclusion, including:</p>

<ul class="standard-list">
  <li>
    All dispatch queues are non-reentrant, meaning you will deadlock if you attempt to dispatch_sync on the current queue.
  </li>
  <li>
    Dispatch queue objects are fairly heavy-weight, clocking in at just about 128 bytes (plus extra space for some internal pointers). Compared to a simple <code>OSSpinLock</code>, which is only 4 bytes.
  </li>
  <li>
    Returning values from a <code>dispatch_sync</code> block gets a little ugly at times, due to requiring a <code>__block</code> variable.
  </li>
  <li>
    Exceptions do not play nicely with dispatch queues.
  </li>
</ul>

<p>These tradeoffs are well worth the performance benefits in most scenarios, and is used widely throughout the SDK.</p>

<h2 id="approach-3-concurrent-dispatch-queue">Approach 3: Concurrent dispatch queue</h2>

<p>Approach #2 is good, in scenarios where read-write balance is even (e.g. same number of gets as sets). However, in the real world, this is very rarely the case. Frequently, you will have logic which includes reading from many times, but only writing occasionally.</p>

<p>Dispatch has built in support for these so-called read-write locks, in the form of Concurrent Queues. These work like most other queues, however, they attempt to let as many executors in as possible, and only get exclusive access when you place a <code class="highlighter-rouge">dispatch_barrier</code>‘d block onto the queue. This allows that queue to run solely in the context of the concurrent queue, and helps to speed our uncontested use-case up significantly.</p>

<pre class="line-numbers"><code class="language-objectivec">@implementation SomeObject() {
    dispatch_queue_t _barQueue; // = dispatch_queue_create("com.parse.example.queue", DISPATCH_QUEUE_CONCURRENT);
}

- (NSInteger)foo {
    __block NSInteger result = 0;
    dispatch_sync(_barQueue, ^{
        result = _foo;
    });
    return result;
}

- (void)incrementFooBy:(NSInteger)x {
    dispatch_barrier_sync(_barQueue, ^{
        _foo += x;
    });
}

@end</code></pre>

<p>As you can see, another advantage of the above code is that it makes a clear contrast between what functions update the instance variables, and which ones don’t. It is important to note the performance overhead of a concurrent dispatch queue versus a serial dispatch queue. In the contested case (e.g. lots of <code class="highlighter-rouge">dispatch_barrier_sync</code> calls), a concurrent dispatch queue will spend a lot more time spinning on its internal lock vs. a serial queue, though it will probably only be noticeable in benchmarks.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Here at Parse, we strive on creating the best APIs possible, with the best threading support possible as well. We do this using a number of mechanisms inside the SDK, which we think are good best practices for any mobile project. Stay tuned in the coming weeks for more posts like this! We’ll be sharing more on our test philosophies, learnings, and more.</p>
</div>
        <div class="copy-block margin-top-40 signature">
            <div>
                <span class="author">Richard Ross</span>
            </div>
            <div class="margin-top-20">
                
                
                
            </div>
        </div>
    </article>
</div>

        </div><!-- /.content__wrapper -->
    </div><!-- /.site__content -->
</div><!-- /.site__wrapper -->
</body>

<script>
    anchors.options = {
      placement: 'left'
    };
    anchors.add();
</script>
</html>
